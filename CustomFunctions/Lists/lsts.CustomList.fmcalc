// lsts.CustomList ( _start; _end; _funciton )
//
// Purpose:		Return a list that applies the start and end values to the function's "[n]" token
// Parameters:		_start:	description
//              		_end:	description
//				_function:	description
//
// Author:			Agnès Barouh (filemaker@tictac.fr), Ugo Di Luca, Grazie Mille
// Version:		updated 08-07-01 by Agnès Barouh
//				updated 10-08-01 by Agnès Barouh to work with FM Go
//				updated 11-11-01 by Agnès Barouh to work with FM SErver
//				4.8 updated 12-11-01 by Agnès Barouh to work with IWP
//
// Notes:			Please, do not used "CLNum" in your calculation with Let()
//
//				Build any list based on all Native or Custom Functions involving a 'Number' value
//				as a parameter, such as : Left(), Middle(), GetValue(), GetRepetitionNumber (),
//				GetNthRecord(), GetLayoutObjectAttribute () ... ex : -
//				CustomList ( 1 ; Get ( FoundCount ) ; "GetNthRecord ( FirstName ; [n] )" ) 
//				will return James¶Henry¶Susan if your foundset has 3 records.
//
//				Build any range based on Dates, Times, TimeStamps, and obviously Numbers
//				ex : CustomList ( 1 ; 5 ; "GetAsDate ( StartingDate ) + [n]" )
//				will return a range of 5 dates starting from the specified StartingDate
//
//				The 'Function' Parameter is nothing else than a litteral calculation expression. 
//				Therefore, CustomList allows for any filtering or parsing process based on any
//				condition you may need. ex : 
//				CustomList ( 10 ; 100 ;
//				  "Let ( [ Value = GetValue ( MyList ; [n] ) ] ; Case ( PatternCount ( Value ; "X" ) ; Value ))" )
//				will parse any value containing a "X" in  the 'MyList' chain, in between the 10th
//				and the 100th values.
//
//				CustomList is based on a totally new algorithm, and is now volontarily bridled
//				to a maximum range of 500,000 values, where the first version was technically
//				limited to a max of 18,700 values. Previous version still available here:
//				http://www.briandunning.com/cf/747
//
//				The new CustomList() is faster and still is NOT recursive. The arguments are
//				unchanged which makes it compatible with all your previous developments
//				involving CustomList().
//
//				For Developper ease, the new CustomList() includes a debugging mode. find
//				the "*****DEBUGGING MODE*****" tag in the formula below to switch mode.
//				When debug is set to 1, any error will be returned with its appropriate
//				explanatory code, else the result will be set to "?"
//
//				Basically, CustomList() does two things :
//				1: Transform your formula in a litteral chain :
//
//				CustomList ( 1; 4; "GetNthRecord ( Field ; [n])")
//				therefore becomes
//				"Let ( [ CLNum = 1 ] ; GetNthRecord ( Field ; CLNum ) ) & ¶ &
//				Let ( [ CLNum = 2 ] ; GetNthRecord ( Field ; CLNum ) ) & ¶ &
//				Let ( [ CLNum = 3 ] ; GetNthRecord ( Field ; CLNum ) ) & ¶ &
//				Let ( [ CLNum = 4 ] ; GetNthRecord ( Field ; CLNum ) )"
//
//				2: Evaluates this chain.
//
//				Interrested in the mechanism ?
//				My advice then : dissect this function by escaping the 'Result' and placing one
//				of the numerous intermediary variables available. Special attention should be
//				paid to the 'First' Variable, everything starts from there!
//
// Todo:			Other functions I've written that have placeholders, such as tmsp.FormatTimestamp,
//				use the percent character to represent the placeholder. Add that as an option to this.
//
// Example:
// lsts.CustomList ( 1 ; 5 ; "Date ( 3; 17; 2015 ) + [n]" ) =
//   "3/18/2015¶3/19/2015¶3/20/2015¶3/21/2015¶3/22/2015"

Case (
  /*This function will not evaluate if Invalid parameters were passed for Start and End.*/
  IsEmpty ( _start )
    or IsEmpty ( _end )
    or ( _end < 1 )
    or ( _start < 1 );
  "";
          
  Let (
    [
      _start	= GetAsNumber ( _start );
      _end	= GetAsNumber ( _end );
      _diff	= _end - _start + 1;

      _version =  Case (
        Left ( Get ( ApplicationVersion ) ; 2 ) = "Go" ;	1 ;
	Left ( Get ( ApplicationVersion ) ; 2 ) = "Se" ;	2 ;
	Left ( Get ( ApplicationVersion ) ; 2 ) = "We" ;	3 ;
										0
      ) ;

      _limit = Choose (
        _version ;
        1700  ;	400 ;		300 ;		900
      ) ;

      // Check for a range higher than 500,000 values  ( max 150000 values for FmGo and
      // 120000 for FmS and 250000 for IWP ). For FMPro/Adv, CustomList() is volontarily
      // restrained to 500 000 but you can but you can go beyond.

      _end = Case (
        ( _diff > Choose ( _version ; 500000  ; 150000 ; 120000 ; 250000 ) )
          or ( _end < _start )
          or IsEmpty ( _start )
          or IsEmpty ( _end );
        "Error";
        _end
      );

      $null = "\"\"";

      // CustomList has its own recursion model. As CustomList may be involved into the
      // "function" argument, each CustomList expression used is passed to a repeating
      // variable for evaluation

      _index = Let (
        [
          $CLExeCount = $CLExeCount + 1
        ];

        $CLExeCount & PatternCount ( _function ; "CustomList" ) + 1
      ) ;

      $CLn[ _index ]  = _start - 1;

      _calc = Case (
        _diff ≥ ( _limit - 10 ) ;	( _limit / 10 )  ;
						Floor ( _diff / 10 ) + 1
      );

      // Here starts the "magic" of the Substitutions and the whole mechanism.
      // CustomList() is set to evaluate stacks of 1,700 values at a time ( 400 for
      // FileMakerGo), which is the current limit of FileMaker internal Evaluate function

      _first				= Substitute ( ( 10 ^ _calc ) - 1; 9; "__________" ) ;  
      _x				= Floor ( _diff / _limit );
      $CLRemainder[ _index ]	= _diff - ( _x * _limit );

      // When the "Function" argument is left empty, CustomList() will return a numeric
      // list based on the range defined

      _function_r = Case (
        IsEmpty ( _function );	"CLNum";
						Substitute ( _function; ["[n]"; "CLNum"] ; [¶ ; ""] )
      );

      // Each repeating variable content is parsed in order to get our String ready for the
      // last evaluation - Special care is made for French users here, please substitute
      // the "definir" below with your local translation of the "Let" function if you're not
      // using an english version. The use of "Let ([" is recommanded anyway */

      $CLExecute[ _index ] = Case (
        Left (
          Substitute (
            Lower ( _function );
            ["definir";	"Let"	];
            [" ";		""	];
            ["¶";		""	]
          );
          5
        ) = "Let([";
        Substitute (
          _first ;
          [ "_";  "Let([$CLn[" & _index & "]=$CLn[" & _index & "]+1;CLNum=$CLn[" & _index & "];" &
            Replace ( _function_r; 1; Position ( _function_r; "["; 1; 1 ); "" ) & "&\¶&¶"]
        );

        Substitute (
          _first ;
          [ "_";  "Let([$CLn[" & _index & "]=$CLn[" & _index & "]+1;CLNum=$CLn[" & _index & "]];" &
            _function_r & ")&\¶&¶"]
        )
      );

      // Final compilation starts here. The reminder part above each 1,700 values is
      // treated now.
  
      _final = Case (
        _x > 0;
        Substitute ( ( 10 ^ _x ) - 1; 9; "Evaluate ( $CLExecute[" & _index & "] & $null ) & " )
      ) &
      "Evaluate( LeftValues ( $CLExecute[" & _index & "] ; $CLRemainder[" & _index & "]  ) & $null ) & " & $null;

      // The Final variable can now be evaluated to get our List

      _result  =   Case (
        _end <> "Error";
        Substitute (
          "#^#" & Evaluate  ( _final ) & "#^#";
          [ "#^#|#^#";	"¶"		];
          [ "¶";		"¶#^#"	];
          [ "#^#¶";		""		];
          [ "¶#^#";		"¶"		];
          [ "¶#^#";		""		];
          [ "#^#";		""		]
        )
      ) ;

      $CLExecute[ _index ]  = "" 

      // ----------- FUNCTION RESULT BELOW -----------
    ];


    // CustomList returns either the valid result, or an error formatted according to the debugging
    // mode chosen above

    Case (
      ( Length ( _result )
        and ( _result = Filter ( _result; "?" ) ) )
      or ( _end =  "Error" );
      Let (
        [
          /*****DEBUGGING MODE*****/

          // Case Debug = 1, returned error "[error_CL], Number, Name and Calculation error",
          // if Debug  <> 1, returned error is "?"

          _debug		= True;
          _write		= Substitute ( _function; "[n]"; 1 );
          _num_error	= EvaluationError ( Evaluate ( _write ) );

          _error = "[" & _num_error & "] " &
            "Unlisted error | Unknown error, check calculation or check \"Start\" and \"End\" ¶" &
            "102 | Field is missing¶" &
            "103 | Relationship is missing¶" &
            "106 | Table is missing¶" &
            "113 | Function is missing¶" &
            "1204 | Number, text constant, field name or \"(\" expected¶" &
            "1205 | Comment is not terminated with \"*/\"¶" &
            "1206 | Text constant must end with a quotation mark¶" &
            "1207 | Unbalanced parenthesis¶" &
            "1208 | Operator or function missing or \"(\" not expected¶" &
            "1211 | List usage is not allowed in this function¶" &
            "1212 | An operator (for example, +, -, *,;) is expected here¶" &
            "1215 | This parameter is an invalid Get function parameter";
          _pos = ValueCount ( Left ( _error; Position ( _error; _num_error & " "; 1; 1 ) ) )
        ];

        Case (
          _debug = 1;	"[Error_CL]  | Return error : " & GetValue ( _error; Case ( _pos = 0; 1; _pos ) ) &
				  ¶ & TextStyleAdd ( "Calculation ( for [n] = 1 ) : "; Bold ) & _write;
				"?"
        )
      );

      _result
    )
  )
)
